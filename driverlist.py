import os
import re
import sys
import argparse
from pathlib import Path
from collections import defaultdict

# Argument parsing
parser = argparse.ArgumentParser(description="Generate FBNeo gamelist from C++ sources.")
parser.add_argument('-o', dest='outfile', required=True, help='Output driver C++ file')
parser.add_argument('-l', dest='listfile', help='Optional gamelist.txt file')
parser.add_argument('inputs', nargs='+', help='Input files or directories')
args = parser.parse_args()

outfile = args.outfile
listfile = args.listfile
inputs = args.inputs

filelist = []

# Collect all relevant input files
for input_path in inputs:
    path = Path(input_path)
    if path.is_dir():
        for entry in path.iterdir():
            if entry.is_file() and re.match(r'd\w?_.+\.cpp$', entry.name):
                filelist.append(str(entry.resolve()))
    elif path.is_file():
        filelist.append(str(path.resolve()))

if not outfile or not filelist:
    print("Usage: script.py -o <output file> [-l <gamelist>] <input file|dir> [<input file|dir>...]")
    sys.exit(1)

# Utilities
def remove_cpp_comments(code):
    code = re.sub(r'//.*', '', code)
    code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)
    return code

def parse_burndriver_struct(content, filename):
    drivers = {}
    lines = content.splitlines()
    i = 0
    while i < len(lines):
        line = lines[i]

        # Remove inline and block comments
        if 'BurnDriver' in line:
            struct_match = re.match(r'.*struct\s+BurnDriver([D|X]?)\s+(\w+)(.*)', line)
            if struct_match:
                status, name, remainder = struct_match.groups()
                struct_body = remainder
                while ';' not in struct_body and i + 1 < len(lines):
                    i += 1
                    struct_body += '\n' + lines[i]
                full_struct = remove_cpp_comments(struct_body)

                # Match the first 14 fields in the struct
                match = re.search(
                    r'\s*(".*?"|null|0)\s*,\s*(".*?"|null|0)\s*,\s*(".*?"|null|0)\s*,\s*(".*?"|null|0)\s*,\s*(".*?"|null|0)\s*,'
                    r'\s*(".*?"|null|0)\s*,\s*(".*?"|null|0)\s*,\s*(".*?"|null|0)\s*,\s*(".*?"|null|0)\s*,\s*(L?".*?"|null|0)\s*,'
                    r'\s*(L?".*?"|null|0)\s*,\s*(L?".*?"|null|0)\s*,\s*(L?".*?"|null|0)\s*,\s*(.*?)[,)]',
                    full_struct,
                    re.DOTALL | re.IGNORECASE
                )

                if match:
                    fields = list(match.groups())
                    fields = ["" if f in ("null", "NULL", "0") else f.strip('"') for f in fields]
                    name_str = fields[0]
                    full_name = fields[5]
                    remarks = fields[6]
                    company = fields[7]
                    hardware = fields[8]
                    year = fields[4]
                    parent = fields[1]
                    flags = fields[13]

                    working = "" if "BDF_GAME_WORKING" in flags or flags == "1" else "NOT WORKING"

                    display_name = full_name
                    tags = []
                    if "BDF_PROTOTYPE" in full_struct:
                        tags.append("Prototype")
                    if "BDF_BOOTLEG" in full_struct:
                        tags.append("Bootleg")
                    if remarks:
                        tags.append(remarks)
                    if tags:
                        display_name += " [" + ", ".join(tags) + "]"

                    drivers[name] = {
                        "status": status,
                        "name": name_str,
                        "full_name": full_name.split('\\0')[0],
                        "remarks": remarks,
                        "company": company,
                        "hardware": hardware,
                        "year": year,
                        "parent": parent,
                        "working": working,
                        "filename": filename,
                        "display_name": display_name
                    }
        i += 1
    return drivers

# Parse all files and collect driver data
all_drivers = {}
for filepath in filelist:
    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()
        drivers = parse_burndriver_struct(content, filepath)
        all_drivers.update(drivers)

# Sort driver keys
driver_keys = sorted(all_drivers.keys(), key=lambda k: all_drivers[k]["display_name"].lower())

# Write .cpp driver file
with open(outfile, 'w', encoding='utf-8') as out:
    out.write(f"""// This file was generated by {sys.argv[0]}

// Declaration of all drivers
#define DRV extern struct BurnDriver
""")
    debug = False
    for key in driver_keys:
        drv = all_drivers[key]
        if drv["status"] == "X":
            out.write("//")
        elif drv["status"] == "D":
            if not debug:
                out.write("#if defined FBNEO_DEBUG\n")
                debug = True
        else:
            if debug:
                out.write("#endif\n")
                debug = False
        out.write(f"DRV\t\t{key};")
        if drv["status"] in ("D", "X"):
            tabs = int((9 + len(key)) / 4)
            out.write("\t" * (8 - tabs))
            out.write(f"// {drv['remarks'] or 'no comment'}")
            if drv["working"]:
                out.write(f" [{drv['working']}]")
        out.write("\n")
    if debug:
        out.write("#endif\n")

    out.write("""#undef DRV

// Structure containing addresses of all drivers
// Needs to be kept sorted (using the full game name as the key) to prevent problems with the gamelist in Kaillera
static struct BurnDriver* pDriver[] = {
""")
    debug = False
    for key in driver_keys:
        drv = all_drivers[key]
        if drv["status"] == "X":
            out.write("//")
        elif drv["status"] == "D":
            if not debug:
                out.write("#if defined FBNEO_DEBUG\n")
                debug = True
        else:
            if debug:
                out.write("#endif\n")
                debug = False
        out.write(f"\t&{key},")
        tabs = int((6 + len(key)) / 4)
        out.write("\t" * (8 - tabs))
        out.write(f"// {drv['full_name']}")
        if drv["status"] in ("D", "X") or drv["working"]:
            out.write(" [")
            out.write(f"{drv['remarks'] or 'no comment'}")
            if drv["working"]:
                out.write(f", {drv['working']}")
            out.write("]")
        out.write("\n")
    if debug:
        out.write("#endif\n")
    out.write("};\n")

print(f"Driver C++ list written to {outfile}")

# Write gamelist.txt if requested
if listfile:
    with open(listfile, 'w', encoding='utf-8') as out:
        out.write("This list contains all games supported by FinalBurn Neo.\r\n\r\n")
        out.write(f"{len(driver_keys)} games supported in total; ")
        out.write("X = excluded from build; D = included in debug build only; NW = not working\r\n\r\n")
        out.write("  name\t\t  status  full name\t\t\t\t\t\t  parent\t  year\t  company\t  hardware\t  remarks\r\n")
        out.write("+" + "-" * 140 + "+\r\n")
        for key in driver_keys:
            drv = all_drivers[key]
            out.write(f"| {drv['name']}\t\t| ")
            status = drv['status'] if drv['status'] else " "
            if drv['working']:
                status += " NW"
            out.write(f"{status}\t| ")
            out.write(f"{drv['full_name'][:54]:<54}\t| ")
            out.write(f"{drv['parent'][:12]:<12}\t| ")
            out.write(f"{drv['year'][:10]:<10}\t| ")
            out.write(f"{drv['company'][:14]:<14}\t| ")
            out.write(f"{drv['hardware'][:14]:<14}\t| ")
            out.write(f"{drv['remarks'][:38]:<38}|\r\n")
        out.write("+" + "-" * 140 + "+\r\n")

    print(f"Gamelist text file written to {listfile}")
